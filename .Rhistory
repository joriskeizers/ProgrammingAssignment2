makeCacheMatrix <- function(x = matrix()) {
## ensure that the matrix m is empty
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
MakeCacheMatrix
x
x = sample(1:6,12)
x = sample(1:6,12,replace = true)
x <- sample(1:6,12,replace=true)
x<-sample(1:6,12)
x = matrix(c(1,9,2,5))
x
x = matrix (x(1,9,2,5),2,2)
x = matrix(c(1,9,2,5),2,2)
x
makeCacheMatrix(x)
x
m
get
y
setsolve
getsolve
m
x
solve(x)
makeCacheMatrix(x)
x
set
m
## These functions are based upon the example shown
## by R. Deng in the preparations for the assignment
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
## ensure that the matrix m is empty
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
CacheInverse <- function(x,...) {
m <-x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data x$get()
m <= solve(data,...)
x$setsolve(m)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
## These functions are based upon the example shown
## by R. Deng in the preparations for the assignment
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
## ensure that the matrix m is empty
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
CacheInverse <- function(x,...) {
m <-x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data,...)
x$setsolve(m)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
makeCacheMatrix(x)
CacheInverse(x)
## These functions are based upon the example shown
## by R. Deng in the preparations for the assignment
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
## ensure that the matrix m is empty
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
CacheInverse <- function(x,...) {
m <-cx$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data,...)
x$setsolve(m)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
## These functions are based upon the example shown
## by R. Deng in the preparations for the assignment
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
## ensure that the matrix m is empty
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
CacheInverse <- function(x,...) {
m <-cx$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data,...)
x$setsolve(m)
}
x
makeCacheMatrix(x)
CacheInverse
CacheInverse(x)
## These functions are based upon the example shown
## by R. Deng in the preparations for the assignment
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
## ensure that the matrix m is empty
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
CacheInverse <- function(x,...) {
m <-x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data,...)
x$setsolve(m)
}
makeCacheMatrix(x)
CacheInverse(x)
## These functions are based upon the example shown
## by R. Deng in the preparations for the assignment
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
## ensure that the matrix m is empty
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
CacheInverse <- function(x,...) {
m <-x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data)
x$setsolve(m)
m
}
test <- matrix(runif(9,1,100),3,3)
test
makeCacheMatrix(test)
test
testCached <- makeCacheMatrix(test)
testinv <- cacheInverse(testCached)
testinv <- CacheInverse(testcached)
testinv <- CacheInverse(testCached)
testinv <- CacheInverse(testCached)
## These functions are based upon the example shown
## by R. Deng in the preparations for the assignment
## This first function calculates - given a matrix x -
## the inverse matrix of x
makeCacheMatrix <- function(x = matrix()) {
## ensure that the matrix m is empty
m <- NULL ## will contain the result
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## The second matrix checks is the inverse matrix of x
## had been calculated before. If so, the cached inverse matrix
## is returned. Otherwise, it is being calculated
CacheInverse <- function(x,...) {
m <-x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data)
x$setsolve(m)
m
}
## These functions are based upon the example shown
## by R. Deng in the preparations for the assignment
## This first function calculates - given a matrix x -
## the inverse matrix of x
makeCacheMatrix <- function(x = matrix()) {
## ensure that the matrix m is empty
m <- NULL ## will contain the result
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## The second matrix checks is the inverse matrix of x
## had been calculated before. If so, the cached inverse matrix
## is returned. Otherwise, it is being calculated
CacheInverse <- function(x,...) {
m <-x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data)
x$setsolve(m)
m
}
test
